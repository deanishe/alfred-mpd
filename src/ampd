#!/usr/bin/python
# encoding: utf-8
#
# Copyright (c) 2017 Dean Jackson <deanishe@deanishe.net>
#
# MIT Licence. See http://opensource.org/licenses/MIT
#
# Created on 2017-03-13
#

"""mpd [options] [args]

Usage:
    mpd search <query>
    mpd stats
    mpd status
    mpd do <action>
    mpd -h | --help
    mpd --version

Options:
    -h, --help      Show this message and exit.
    --version       Show version number and exit.

Commands:
    search          Search tracks
    stats           Show MPD library stats
    status          Show MPD server status
    do              Perform a non-interactive action

"""

from __future__ import print_function, absolute_import

from collections import namedtuple
import os
# import subprocess
import sys

from lib.docopt import docopt
from lib.workflow import Workflow3
from lib.workflow.notify import notify

from lib import mpd

log = None

# Initial values for `settings.json`
DEFAULT_SETTINGS = {}

# Auto-update from GitHub releases
UPDATE_SETTINGS = {
    'github_slug': 'deanishe/alfred-mpd',
}

HELP_URL = u'https://github.com/deanishe/alfred-mpd/issues'

ICON_ALBUM = u'icons/album.png'
ICON_ARTIST = u'icons/artist.png'
ICON_CLEAR = u'icons/playlist-clear.png'
ICON_ERROR = u'icons/error.png'
ICON_PLAY = u'icons/play.png'
ICON_PLAYLIST = u'icons/playlist.png'
ICON_MUTE = u'icons/volume-off.png'
ICON_NEXT = u'icons/next.png'
ICON_PREVIOUS = u'icons/previous.png'
ICON_STOP = u'icons/stop.png'
ICON_TRACK = u'icons/track.png'
ICON_TRACK_QUEUED = u'icons/track-queued.png'
ICON_TYPE = u'icons/tag.png'
ICON_UPDATE_AVAILABLE = u'icons/update-available.png'
ICON_UPDATE_OK = u'icons/update-ok.png'
ICON_VOLUME_UP = u'icons/volume-up.png'
ICON_VOLUME_DOWN = u'icons/volume-down.png'
ICON_WARNING = u'icons/warning.png'
ICON_WF = u'icon.png'


mpd.MAX_RESULTS = int(os.getenv('MAX_RESULTS') or '100')


# currently using a second action in the workflow
# to re-open the Script Filter

# def _applescriptify(s):
#     """Make string AppleScript safe."""
#     return s.replace('"', '" & quot &"')


# def recall(query=None):
#     """Call this Script Filter again with query."""
#     script = (u'tell application "Alfred 3" to '
#               u'run trigger "search" in workflow "net.deanishe.alfred.mpd"')
#     if query:
#         script += u' with argument "{}"'.format(_applescriptify(query))
#     cmd = ['/usr/bin/osascript', '-e', script.encode('utf-8')]
#     subprocess.check_call(cmd)


def _track_from_env():
    """Create an `mpd.Track` from Alfred's envvars."""
    return mpd.Track(
        *[wf.decode(os.getenv('ampd_' + k) or '')
          for k in ('artist', 'album', 'disc', 'track', 'title', 'file')])


def do_action(opts):
    """Perform a workflow action."""
    query = wf.decode(os.getenv('ampd_query') or '')
    action = opts.get('<action>')
    track = _track_from_env()

    log.debug('query=%r, action=%r, track=%r', query, action, track)

    simple_actions = {
        'playpause': mpd.playpause,
        'clear': mpd.clear,
        'mute': mpd.mute,
        'next': mpd.skip_next,
        'previous': mpd.skip_previous,
        'stop': mpd.stop,
        'turn-up': mpd.volume_up,
        'turn-down': mpd.volume_down,
    }

    # parse action
    for action in action.split('+'):
        if action in simple_actions:
            simple_actions[action]()

        elif action == 'queue':
            log.debug('queuing track ...')
            mpd.queue_track(track)
            notify(u'Queued Track',
                   u'"{t.title}" by {t.artist}'.format(t=track))

        elif action == 'remove':
            log.debug('removing track ...')
            mpd.remove_track(track)
            notify(u'Removed Track',
                   u'"{t.title}" by {t.artist}'.format(t=track))

        elif action == 'play':  # queue track and play last track in queue
            log.debug('queuing and playing song ...')
            for i, t in enumerate(mpd.queue()):

                if t.file == track.file:  # track already in queue
                    mpd.play(i + 1)
                    return

            mpd.queue_track(track)
            mpd.play(len(mpd.queue()))

        elif action == 'queue-album':
            log.debug('queuing album ...')

            for track in mpd.find(u'album:{}'.format(track.album)):
                mpd.queue_track(track)

            notify(u'Queued Album',
                   u'"{t.album}" by {t.artist}'.format(t=track))

        else:
            msg = u'unknown action: ' + action
            notify(u'ERROR', msg)
            raise ValueError(msg)


Action = namedtuple('Action', 'title subtitle keywords action icon')


def search_actions(query):
    """Return workflow actions matching query."""
    st = mpd.status()
    queue = mpd.queue()

    actions = [
        Action(
            'Play/Pause',
            'Start or stop playback',
            'play pause',
            'playpause',
            ICON_PLAY)
    ]

    if st.volume > 0:
        actions.extend([
            Action(
                'Mute Volume',
                'Set volume to zero',
                'volume mute',
                'mute',
                ICON_MUTE),
            Action(
                'Volume Down',
                'Decrease volume to {}%'.format(st.volume - 10),
                'volume down quiet decrease',
                'turn-down',
                ICON_VOLUME_DOWN),
        ])

    if st.volume < 100:
        actions.append(
            Action(
                'Volume Up',
                'Increase volume to {}%'.format(st.volume + 10),
                'volume up loud increase',
                'turn-up',
                ICON_VOLUME_UP)
        )

    canprev = cannext = False
    if len(queue):
        actions.append(
            Action(
                'Clear Queue',
                'Remove all tracks from the queue',
                'clear reset',
                'clear',
                ICON_CLEAR))

        if st.index > 1:
            canprev = True
        if st.index < st.total:
            cannext = True

    if st.playing:
        actions.append(
            Action(
                'Stop',
                'Stop playback',
                'stop',
                'stop',
                ICON_STOP))

    if canprev:
        actions.append(
            Action(
                'Previous Track',
                'Play previous track',
                'previous skip',
                'previous',
                ICON_PREVIOUS))

    if cannext:
        actions.append(
            Action(
                'Next Track',
                'Play next track',
                'next skip',
                'next',
                ICON_NEXT))

    return wf.filter(query, actions, key=lambda a: a.keywords, min_score=30)


def do_search(opts):
    """Search MPD and return results to Alfred."""
    query = opts.get('<query>').strip()
    if not query:
        return do_stats(opts)

    actions = search_actions(query)

    if actions:
        for a in actions:
            it = wf.add_item(
                a.title,
                a.subtitle,
                autocomplete=a.title,
                arg=a.action,
                uid='ampd.action.' + a.action,
                valid=True,
                icon=a.icon,
            )
            it.setvar('ampd_action', a.action)
            it.setvar('ampd_reopen', 'yes')

    try:
        tracks = mpd.search(query)
    except mpd.InvalidType as exc:
        wf.add_item(exc.msg, exc.reason, icon=ICON_ERROR)
        wf.send_feedback()
        return

    log.debug(u'%d result(s) for "%s"', len(tracks), query)

    if not tracks and not actions:
        wf.add_item(u'No results', u'Try a different query?',
                    icon=ICON_WARNING)
        wf.send_feedback()
        return

    # pass query to downstream actions to call Alfred again
    wf.setvar('ampd_query', query)

    # load queue, so we can change the track icon, etc.
    # if it's already in the queue
    queued = {t.file for t in mpd.queue()}

    for t in tracks:
        inq = t.file in queued
        full = u'{t.artist} - {t.album} - {t.track} - {t.title}'.format(t=t)
        uid = u'{}-{}-{}-{}'.format(*t).lower()

        icon = ICON_TRACK
        sub = u'{t.artist} - {t.album}'.format(t=t)
        action = 'queue'

        if inq:
            icon = ICON_TRACK_QUEUED
            action = 'remove'
            sub = u'[queued] ' + sub

        it = wf.add_item(t.title, sub,
                         autocomplete=u'{} '.format(t.title),
                         arg=t.file,
                         uid=uid,
                         copytext=full,
                         largetext=full,
                         valid=True,
                         icon=icon)

        it.setvar('ampd_artist', t.artist)
        it.setvar('ampd_album', t.album)
        it.setvar('ampd_title', t.title)
        it.setvar('ampd_file', t.file)
        it.setvar('ampd_action', action)
        it.setvar('ampd_reopen', 'yes')

        m = it.add_modifier('cmd', u'Play this track')
        m.setvar('ampd_action', 'play')

        m = it.add_modifier('alt', u'Clear queue & play this track')
        m.setvar('ampd_action', 'clear+play')

        m = it.add_modifier('ctrl', u'Queue album')
        m.setvar('ampd_action', 'queue-album')

    wf.send_feedback()
    return


def _plural(s, n, plural=None):
    """Pluralise string ``s`` based on count ``n``."""
    if n == 1:
        return u'{} {}'.format(n, s)
    if plural:
        return u'{} {}'.format(n, plural)

    return u'{} {}s'.format(n, s)


def do_stats(opts):
    """Fetch MPD stats and show in Alfred."""
    st = mpd.stats()

    if not st.songs:  # empty library
        wf.add_item(u'MPD library empty',
                    u'Update your library or add some tracks',
                    icon=ICON_WARNING)
        wf.send_feedback()
        return

    ntypes = len(mpd.types())
    nplaylists = len(mpd.playlists())
    cur_track = mpd.current()
    queue = mpd.queue()

    if cur_track:  # name of current track, actions play/pause
        log.debug(u'current=%r', cur_track)

        playing = mpd.playing()
        name = u'"{t.title}" by {t.artist}'.format(t=cur_track)
        status = u'Now Playing: ' if playing else u'Paused: '

        it = wf.add_item(
            status + name,
            u'Track {t.track} of "{t.album}"'.format(t=cur_track),
            arg=cur_track.file,
            valid=True,
        )
        it.setvar('ampd_action', 'playpause')
        it.setvar('ampd_reopen', 'yes')

    else:  # server host info
        wf.add_item(u'MPD running on {}:{}'.format(
                    mpd.MPD_HOST, mpd.MPD_PORT))

    if len(queue):
        wf.add_item(
            u'{} in queue'.format(_plural(u'track', len(queue))),
            valid=False,
            icon=ICON_PLAYLIST,
        )

    # artists, albums, etc.
    # TODO: drill down into artists/albums/playlists etc.
    wf.add_item(_plural('artist', st.artists), icon=ICON_ARTIST)
    wf.add_item(_plural('album', st.albums), icon=ICON_ALBUM)
    wf.add_item(_plural('playlist', nplaylists), icon=ICON_PLAYLIST)
    wf.add_item(_plural('song', st.songs), icon=ICON_TRACK)
    # MPD search types
    wf.add_item(_plural('search type', ntypes), icon=ICON_TYPE)

    wf.send_feedback()


def do_status(opts):
    """Show MPD server status."""
    s = mpd.status()
    log.debug('status=%r', s)


def main(wf):
    """Run workflow script."""
    opts = docopt(__doc__, argv=wf.args, version=wf.version)

    log.debug('opts=%r', opts)
    log.debug('mpd: host=%s, port=%s', mpd.MPD_HOST, mpd.MPD_PORT)

    try:
        if opts['search']:
            return do_search(opts)
        elif opts['stats']:
            return do_stats(opts)
        elif opts['status']:
            return do_status(opts)
        elif opts['do']:
            return do_action(opts)

    except mpd.ConnectionError as err:
        wf.add_item(err.msg, err.reason, valid=False, icon=ICON_ERROR)
        wf.send_feedback()


if __name__ == '__main__':
    wf = Workflow3(
        default_settings=DEFAULT_SETTINGS,
        # TODO: enable updates
        # update_settings=UPDATE_SETTINGS,
        help_url=HELP_URL,
    )
    log = wf.logger
    sys.exit(wf.run(main))
